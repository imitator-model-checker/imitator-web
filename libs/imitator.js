const path = require('path');
const glob = require('fast-glob');
const config = require('../config');
const { v4: uuidv4 } = require('uuid');
const stripAnsi = require('strip-ansi');
const { spawn } = require('child_process');
const { zipFiles } = require('../libs/archiver');

/**
 * Return the command to execute imitator
 *
 * @param {String} mode execution mode
 *
 * @returns Array<String>
 */
function getImitatorCommand(mode) {
  if (mode === 'docker') {
    const outputFolder = config.uploadFolder;
    return {
      command: 'docker',
      extraArguments: [
        'run',
        '--rm',
        '-v',
        `${outputFolder}:${outputFolder}`,
        config.imitatorPath,
      ],
    };
  } else {
    return {
      command: config.imitatorPath,
      extraArguments: [],
    };
  }
}

/**
 * Run imitator
 *
 * @param {String} model Absoule path of the imitator model file
 * @param {String} property  Absolute path of the imitator property file
 * @param {Array<String>} options List of imitator options
 * @param {Number} timeout timeout of execution
 *
 * @returns Promise<String>
 */
function runImitator(model, property, options, timeout) {
  return new Promise((resolve, reject) => {
    // output folder
    const outputFolder = config.uploadFolder;

    // imitator output prefix
    const outputPrefix = path.join(outputFolder, uuidv4());

    // result of imitator
    const result = {
      output: '',
      error: '',
    };

    // get the corresponding imitator command to be executed
    const { command, extraArguments } = getImitatorCommand(config.imitatorMode);

    // imitator execution
    const imitator = spawn(command, [
      ...extraArguments,
      model,
      property,
      '-output-prefix',
      outputPrefix,
      ...options,
    ]);

    // kill process if timeout is reached
    if (timeout) {
      setTimeout(() => {
        imitator.kill();
        return reject(new Error('Timeout'));
      }, timeout * 1000);
    }

    // accumulate imitator output
    imitator.stdout.on('data', (stdout) => {
      // @ts-ignore
      result.output += stripAnsi(stdout.toString());
    });

    // accumulate imitator error output
    imitator.stderr.on('data', (stderr) => {
      // @ts-ignore
      result.error += stripAnsi(stderr.toString());
    });

    // return result when imitator finishes
    imitator.on('exit', async (code) => {
      try {
        if (code !== 0) return reject(result.error);

        // files generated by imitator
        const patternGeneratedFiles = `${outputPrefix}*`;

        // zip files
        const zipFile = await zipFiles(outputFolder, [
          { path: model, name: 'model.imi', type: 'file' },
          { path: property, name: 'property.imiprop', type: 'file' },
          { path: result.output, name: 'stdout.txt', type: 'string' },
          { pattern: patternGeneratedFiles, type: 'glob' },
        ]);

        // remove temporary files
        const files = await glob(patternGeneratedFiles);

        resolve({
          files: files.map((f) => path.basename(f)),
          zip: path.basename(zipFile),
          output: result.output,
        });
      } catch (err) {
        reject(err);
      }
    });

    // catch error
    imitator.on('error', (error) => reject(error));
  });
}

module.exports = { runImitator };
