const ps = require('ps');
const path = require('path');
const glob = require('fast-glob');
const process = require('process');
const config = require('../config');
const stripAnsi = require('strip-ansi');
const { flatArray } = require('./utils');
const { zipFiles } = require('./archiver');
const { spawn } = require('child_process');

/**
 * Return the command to execute imitator
 *
 * @param {String} mode execution mode
 *
 * @returns Array<String>
 */
function getImitatorCommand(mode) {
  if (mode === 'docker') {
    const outputFolder = config.uploadFolder;
    return {
      command: 'docker',
      extraArguments: [
        'run',
        '--rm',
        '-v',
        `${outputFolder}:${outputFolder}`,
        config.imitatorPath,
      ],
    };
  } else {
    return {
      command: config.imitatorPath,
      extraArguments: [],
    };
  }
}

/**
 * Run imitator
 *
 * @param {String} model Absolute path of the imitator model file
 * @param {String} property  Absolute path of the imitator property file
 * @param {Array<String>} options List of imitator options
 * @param {String} outputFolder folder where the imitator output will be saved
 * @param {any} socket socket listening the output of imitator
 *
 * @returns Promise<String>
 */
function runImitator(model, property, options, outputFolder, socket) {
  return new Promise((resolve, reject) => {
    // result of imitator
    const result = {
      output: '',
      error: '',
    };

    // get the corresponding imitator command to be executed
    const { command, extraArguments } = getImitatorCommand(config.imitatorMode);

    const modelName = path.basename(model, path.extname(model));
    const outputPrefix = path.join(outputFolder, modelName);

    const propertyOptional = property ? [property] : [];

    // imitator execution
    const imitator = spawn(command, [
      ...extraArguments,
      model,
      ...propertyOptional,
      '-output-prefix',
      outputPrefix,
      ...options,
    ]);

    // accumulate imitator output
    imitator.stdout.setEncoding('utf-8');
    imitator.stdout.on('data', (stdout) => {
      // @ts-ignore
      result.output += stripAnsi(stdout.toString());
      socket.emit('imitator_output', modelName, 'stdout', result.output);
    });

    // accumulate imitator error output
    imitator.stderr.setEncoding('utf-8');
    imitator.stderr.on('data', (stderr) => {
      // @ts-ignore
      result.error += stripAnsi(stderr.toString());
      socket.emit('imitator_output', modelName, 'error', result.error);
    });

    // return result when imitator finishes
    imitator.on('exit', async (code) => {
      if (code !== 0) {
        socket.emit('imitator_output', modelName, 'error', result.error);
        return reject(result.error);
      }

      // files generated by imitator
      const files = await glob(`${outputPrefix}*.!(zip)`);

      if (property) {
        files.push(property);
      }

      socket.emit('imitator_output', modelName, 'files', {
        path: path.basename(outputFolder),
        files: files.map((f) => path.basename(f)),
      });

      socket.emit('imitator_exit');
    });

    // catch error
    imitator.on('error', (error) => reject(error));

    resolve({
      outputFolder,
      pid: imitator.pid,
      prefix: modelName,
    });
  });
}

/**
 * Compress all the imitator output in a zip file
 *
 * @param {Array<Object>} outputs imitator outputs
 * @param {String} outputFolder folder where the zip file will be saved
 *
 * @returns String
 */
async function zipImitatorFiles(outputs, outputFolder) {
  const imitatorOutputFolder = outputs.length ? outputs[0].outputFolder : '';

  const stdoutFiles = outputs.map((o) => ({
    path: o.stdout,
    name: `${o.prefix}.txt`,
    type: 'string',
  }));

  const generatedFiles = [
    ...new Set(flatArray(outputs.map((o) => o.files))),
  ].map((f) => ({
    path: path.join(imitatorOutputFolder, f),
    name: f,
    type: 'file',
  }));

  const zipFilename = await zipFiles(
    path.join(outputFolder, 'imitator-output.zip'),
    [...stdoutFiles, ...generatedFiles]
  );

  return zipFilename;
}

/**
 * Stop a running imitator job
 *
 * @param {Number} pid imitator job pid
 */
async function stopImitator(pid) {
  // @ts-ignore
  const processes = await ps({ pid });

  return new Promise((resolve, reject) => {
    if (!processes.length) return resolve();

    // catch error
    process.on('error', (error) => reject(error));

    // kill job
    process.kill(pid);
    return resolve();
  });
}

module.exports = { runImitator, zipImitatorFiles, stopImitator };
